<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>着順判定らくらく君</title>
<style>
  body {
    margin: 0;
    font-family: "Segoe UI", sans-serif;
    background: #fafafa;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
  }
  header {
    text-align: center;
    background: #0078d7;
    color: white;
    width: 100%;
    padding: 10px 0;
    font-size: 1.2rem;
    font-weight: bold;
  }
  #video-container {
    position: relative;
    width: 90vw;
    max-width: 500px;
    aspect-ratio: 4/3;
    overflow: hidden;
    border: 2px solid #0078d7;
    border-radius: 10px;
    margin-top: 10px;
  }
  video, canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
  }
  #controls {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
  }
  button {
    padding: 10px 14px;
    font-size: 1rem;
    border: none;
    border-radius: 8px;
    color: white;
    background-color: #0078d7;
    cursor: pointer;
    transition: 0.2s;
  }
  button:hover { background-color: #005fa3; }
  #status {
    margin-top: 5px;
    font-size: 0.9rem;
    color: #555;
  }
  #results {
    width: 90vw;
    max-width: 500px;
    margin-top: 10px;
    background: white;
    border-radius: 10px;
    padding: 8px;
    box-shadow: 0 0 4px rgba(0,0,0,0.2);
  }
  table {
    width: 100%;
    border-collapse: collapse;
  }
  th, td {
    padding: 4px;
    text-align: center;
    border-bottom: 1px solid #ddd;
  }
  th { background-color: #f0f0f0; }
  #info {
    font-size: 0.85rem;
    color: #333;
    background: #fff3cd;
    padding: 8px;
    margin: 8px;
    border-left: 4px solid #ffca28;
    border-radius: 5px;
  }
</style>
</head>
<body>
  <header>着順判定らくらく君 🏁</header>

  <div id="info">
    💡スリット幅とは：カメラが「通過ライン」を読み取る幅のことです。<br>
    幅が広いほど検出が安定しますが、反応が少し遅れます。
  </div>

  <div id="video-container">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="controls">
    <button id="startBtn">▶ スタート</button>
    <button id="stopBtn">⏸ ストップ</button>
    <button id="resetBtn">🔄 リセット</button>
  </div>

  <div id="status">カメラ準備中...</div>

  <div id="results">
    <table>
      <thead>
        <tr><th>順位</th><th>色</th><th>タイム(秒)</th></tr>
      </thead>
      <tbody id="resultTableBody"></tbody>
    </table>
  </div>

<script>
let video = document.getElementById('video');
let canvas = document.getElementById('overlay');
let ctx = canvas.getContext('2d');
let scanning = false;
let slitY = 0;
let results = [];
let stopwatchInterval, startTime;

// === カメラ起動 ===
navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
.then(stream => {
  video.srcObject = stream;
  video.onloadedmetadata = () => {
    video.play();
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    slitY = canvas.height / 2;
    drawLine();
    document.getElementById("status").textContent = "準備完了：スタートを押してください";
  };
}).catch(err => {
  alert("カメラにアクセスできません: " + err);
});

// === ライン描画 ===
function drawLine() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "lime";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, slitY);
  ctx.lineTo(canvas.width, slitY);
  ctx.stroke();
  if (!scanning) requestAnimationFrame(drawLine);
}

// === RGB→HSV変換 ===
function rgbToHsv(r, g, b) {
  r /= 255; g /= 255; b /= 255;
  let max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, v = max;
  let d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max === min) h = 0;
  else {
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  return [h * 360, s * 100, v * 100];
}

// === 色検出（HSVベース） ===
function detectColor() {
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  let frame = ctx.getImageData(0, slitY, canvas.width, 3); // 3px幅サンプル
  let totalH = 0, totalS = 0, totalV = 0, count = 0;
  
  for (let i = 0; i < frame.data.length; i += 4) {
    const [r, g, b] = frame.data.slice(i, i + 3);
    const [h, s, v] = rgbToHsv(r, g, b);
    totalH += h; totalS += s; totalV += v; count++;
  }
  const avgH = totalH / count;
  const avgS = totalS / count;
  const avgV = totalV / count;

  let color = null;

  // === HSV色相ベースの安定判定 ===
  if ((avgH < 15 || avgH > 340) && avgS > 50 && avgV > 40) color = "赤";
  else if (avgS < 20 && avgV > 80) color = "白";
  else if (avgS > 40 && avgV > 40) color = "マルチ色";

  if (color && !results.some(r => r.color === color)) {
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
    results.push({ rank: results.length + 1, color, time: elapsed });
    updateTable();
  }

  if (scanning) requestAnimationFrame(detectColor);
}

// === テーブル更新 ===
function updateTable() {
  const tbody = document.getElementById("resultTableBody");
  tbody.innerHTML = results.map(r =>
    `<tr><td>${r.rank}</td><td>${r.color}</td><td>${r.time}</td></tr>`
  ).join("");
}

// === ストップウォッチ機能 ===
function startStopwatch() {
  startTime = Date.now();
  stopwatchInterval = setInterval(() => {
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
    document.getElementById("status").textContent = `計測中：${elapsed} 秒`;
  }, 100);
}
function stopStopwatch() {
  clearInterval(stopwatchInterval);
}

// === ボタン操作 ===
document.getElementById('startBtn').onclick = () => {
  if (!scanning) {
    scanning = true;
    results = [];
    updateTable();
    startStopwatch();
    requestAnimationFrame(detectColor);
  }
};
document.getElementById('stopBtn').onclick = () => {
  scanning = false;
  stopStopwatch();
  document.getElementById("status").textContent = "停止中";
  drawLine();
};
document.getElementById('resetBtn').onclick = () => {
  scanning = false;
  results = [];
  updateTable();
  stopStopwatch();
  document.getElementById("status").textContent = "リセット完了";
  drawLine();
};
</script>
</body>
</html>
