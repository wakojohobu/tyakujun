<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ラインスキャン 着順判定 完全版</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
#video-wrapper { position: relative; width: 100%; aspect-video; background-color: #000; border-radius: 12px; overflow: hidden; margin-bottom: 12px; }
#video { width: 100%; height: 100%; object-fit: cover; }
#scan-line { position: absolute; top:0; height:100%; width:2px; background:red; z-index:20; pointer-events:none; }
#capture-canvas { display:none; }
#result-canvas { width:100%; height:200px; background:#111; display:block; }
table { width:100%; border-collapse: collapse; }
th, td { border:1px solid #ccc; padding:4px; text-align:center; font-size:0.875rem; }
.scrollable { overflow-x:auto; }
</style>
</head>
<body class="p-4">

<h1 class="text-2xl font-bold text-center text-indigo-700 mb-4">🏁 ラインスキャン 着順判定 完全版</h1>

<!-- コントロールパネル -->
<div class="grid grid-cols-1 md:grid-cols-3 gap-2 mb-4">

  <div class="flex flex-col space-y-2">
    <button id="setup-camera-button" class="bg-green-600 hover:bg-green-700 text-white py-2 rounded">📷 カメラ起動</button>
    <select id="camera-select" class="p-2 border rounded" disabled>
      <option>カメラを起動してください</option>
    </select>
  </div>

  <div class="flex flex-col space-y-2">
    <button id="start-button" class="bg-indigo-600 hover:bg-indigo-700 text-white py-2 rounded" disabled>▶️ スキャン開始</button>
    <button id="stop-button" class="bg-red-500 hover:bg-red-600 text-white py-2 rounded hidden">⏹️ スキャン停止</button>
  </div>

  <div class="flex flex-col space-y-2">
    <button id="sw-start" class="bg-blue-600 hover:bg-blue-700 text-white py-2 rounded">⏱️ ストップウォッチ スタート</button>
    <button id="sw-stop" class="bg-blue-400 hover:bg-blue-500 text-white py-2 rounded">⏹️ 停止</button>
    <button id="sw-reset" class="bg-gray-400 hover:bg-gray-500 text-white py-2 rounded">🔄 リセット</button>
  </div>

</div>

<!-- スリット幅調整 -->
<div class="mb-4 bg-white p-2 rounded shadow">
  <label for="scan-offset" class="font-semibold">スリット幅調整 (ピクセル):</label>
  <input type="range" id="scan-width" min="1" max="20" value="2" step="1" class="w-full">
  <p class="text-sm text-gray-600">スリット幅が広いほど通過選手の形が太く、判定しやすいが細かい動きは不明瞭に。狭いほど個別位置は鮮明だが検出に弱くなる。</p>
</div>

<!-- 映像プレビュー -->
<div id="video-wrapper">
  <video id="video" playsinline autoplay muted></video>
  <div id="scan-line"></div>
</div>

<!-- ラインスキャン結果 -->
<h2 class="text-lg font-semibold mb-2">ラインスキャン画像</h2>
<canvas id="result-canvas"></canvas>

<!-- ランキング表 -->
<h2 class="text-lg font-semibold mt-4 mb-2">着順・タイム一覧</h2>
<div class="scrollable">
<table>
<thead>
<tr>
  <th>着順</th>
  <th>チーム</th>
  <th>タイム</th>
</tr>
</thead>
<tbody id="ranking-body">
</tbody>
</table>
</div>

<!-- 非表示キャプチャ用 -->
<canvas id="capture-canvas"></canvas>

<script>
const video = document.getElementById('video');
const captureCanvas = document.getElementById('capture-canvas');
const captureCtx = captureCanvas.getContext('2d');
const resultCanvas = document.getElementById('result-canvas');
const resultCtx = resultCanvas.getContext('2d');

const setupCameraButton = document.getElementById('setup-camera-button');
const startButton = document.getElementById('start-button');
const stopButton = document.getElementById('stop-button');
const cameraSelect = document.getElementById('camera-select');

const scanLine = document.getElementById('scan-line');
const scanWidthInput = document.getElementById('scan-width');

const swStart = document.getElementById('sw-start');
const swStop = document.getElementById('sw-stop');
const swReset = document.getElementById('sw-reset');
let swInterval = null;
let swTime = 0;

const rankingBody = document.getElementById('ranking-body');

let stream = null;
let scanning = false;
let scanX = 0;
const FRAME_WIDTH = 1;
const RESULT_HEIGHT = 200;

let trackResults = [];

let videoDevices = [];

// ---------------------------------------------------
// ストップウォッチ
// ---------------------------------------------------
function updateStopwatchDisplay() {
  document.title = `⏱️ ${formatTime(swTime)}`;
}
function formatTime(ms) {
  const s = Math.floor(ms/1000);
  const cs = Math.floor((ms%1000)/10);
  return String(s).padStart(2,'0')+':'+String(cs).padStart(2,'0');
}
swStart.onclick = ()=>{ if(!swInterval) swInterval=setInterval(()=>{swTime+=10; updateStopwatchDisplay()},10);}
swStop.onclick = ()=>{ if(swInterval){clearInterval(swInterval); swInterval=null;}}
swReset.onclick = ()=>{swTime=0; updateStopwatchDisplay();}

// ---------------------------------------------------
// カメラ
// ---------------------------------------------------
setupCameraButton.onclick = async ()=>{
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null;}
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment',frameRate:{ideal:60}}, audio:false});
    video.srcObject = stream;
    await video.play();
    startButton.disabled=false;
    cameraSelect.disabled=false;
  } catch(e){ alert('カメラ起動失敗:'+e);}
};

// ---------------------------------------------------
// スキャン
// ---------------------------------------------------
startButton.onclick = ()=>{ scanning=true; scanX=0; resultCanvas.width=1; trackResults=[]; startButton.disabled=true; stopButton.classList.remove('hidden'); scanLoop();}
stopButton.onclick = ()=>{
  scanning=false; stopButton.classList.add('hidden'); startButton.disabled=false;
  if(swInterval){ clearInterval(swInterval); swInterval=null; } // SWも停止
};

function scanLoop(){
  if(!scanning) return;
  captureCanvas.width=video.videoWidth; captureCanvas.height=video.videoHeight;
  captureCtx.drawImage(video,0,0,captureCanvas.width,captureCanvas.height);
  
  const width = parseInt(scanWidthInput.value);
  const scanXPos = Math.floor(captureCanvas.width/2 - width/2);
  const imageData = captureCtx.getImageData(scanXPos,0,width,captureCanvas.height);

  // HSV変換して色判定
  const hValues = [];
  const teamsDetected = [];
  for(let y=0;y<imageData.height;y++){
    for(let x=0;x<imageData.width;x++){
      const idx=(y*imageData.width+x)*4;
      const r=imageData.data[idx];
      const g=imageData.data[idx+1];
      const b=imageData.data[idx+2];
      const hsv=rgb2hsv(r,g,b);
      const h=hsv[0], s=hsv[1], v=hsv[2];
      let team='';
      if(v>0.2 && s>0.4){
        if(h>=0 && h<20) team='赤';
        else if(h>=160 && h<=180) team='赤';
        else if(h>=40 && h<90) team='黄';
        else if(h>=100 && h<140) team='青';
        else if(h>=20 && h<40) team='橙';
        else if(h>=140 && h<160) team='紫';
        else team='白';
      }
      if(team) teamsDetected.push(team);
    }
  }
  const uniqueTeams=[...new Set(teamsDetected)];
  uniqueTeams.forEach(team=>{
    const exists=trackResults.find(t=>t.team===team);
    if(!exists){
      trackResults.push({team:team,time:swTime});
      updateRankingTable();
    }
  });

  // 結果キャンバス描画
  const resultWidth=resultCanvas.width;
  resultCanvas.width=resultWidth+FRAME_WIDTH;
  resultCanvas.height=RESULT_HEIGHT;
  if(resultWidth>0) resultCtx.drawImage(resultCanvas,0,0,resultWidth,RESULT_HEIGHT,resultWidth,0,resultWidth,RESULT_HEIGHT); 
  const tempCanvas=document.createElement('canvas'); tempCanvas.width=FRAME_WIDTH; tempCanvas.height=imageData.height;
  tempCanvas.getContext('2d').putImageData(imageData,0,0);
  resultCtx.drawImage(tempCanvas,resultWidth,0,FRAME_WIDTH,RESULT_HEIGHT);

  scanX+=FRAME_WIDTH;
  requestAnimationFrame(scanLoop);
}

// HSV変換
function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  const d=max-min;
  let h=0,s=0,v=max;
  s=max===0?0:d/max;
  if(d!==0){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h=Math.round(h*60); if(h<0) h+=360;
  }
  return [h,s,v];
}

// ランキング表更新
function updateRankingTable(){
  rankingBody.innerHTML='';
  trackResults.sort((a,b)=>a.time-b.time).forEach((r,i)=>{
    const tr=document.createElement('tr');
    const td1=document.createElement('td'); td1.textContent=i+1;
    const td2=document.createElement('td'); td2.textContent=r.team;
    const td3=document.createElement('td'); td3.textContent=formatTime(r.time);
    tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
    rankingBody.appendChild(tr);
  });
}
</script>
</body>
</html>
